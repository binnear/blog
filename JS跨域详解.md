因项目本地开发时，调用API都是涉及到跨域的问题，而现在前端工程化，前端构建工具会集成跨域的功能，因此也没有深入地区探究跨域的问题，而自己本身也对跨域问题还有一些模糊之处，因此决定写下这篇文章，督促自己了解的同时，也是做个记录，方便以后回顾。

#### 本文目录结构：
---

1. 什么是跨域
2. 现阶段跨域的解决方案及案例
3. 最佳实践

#### 一、什么是跨域
---

##### 1. 跨域的两个误区

> 1.动态请求就会有跨域问题
> 2.跨域就是请求发不出去

对于误区1，跨域仅仅存在与浏览器端，不存在于其他环境；对于误区2，只要网络没有问题，所有跨域的请求都是能正常发送出去，并且服务端也能收到请求并正常返回结果，只是由于跨域限制，被浏览器拦截了。（这也是为什么我们用postman等代理工具模拟请求时，可以获取到返回信息。）

##### 2. 为什么跨域仅仅限制读取远端的数据

如果限制写入端（也就是发送请求端），那么服务器的资源仅仅只能同源请求，无法做到资源共享。

##### 3. 浏览器如何识别一个请求是否跨域

> 浏览器识别跨域是基于[同源策略][sameOrigin]
[sameOrigin]: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy

同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
  
如果两个页面的协议（如：`http`,`https`）、域名（如：`binnera.com.cn`）、端口（一般web网站都是默认80端口）都相同，则两个页面具有相同的源，而只要其中任意一个不同，则浏览器则会将这两个源之间的请求视为跨域。

##### 4. 浏览器跨域限制主要限制了什么

> 1. 不同的源无法读取对方的`Cookie`、`LocalStorage` 和 `IndexDB`；
> 2. 无法获取`DOM`,`BOM`；
> 3. JS无法获取`AJAX`请求的结果。

##### 5. 跨域三种限制所应对的实际问题

> 1. 如果能读取其他源的`cookie`，那么就可以获取你的登陆了信息，模拟你的登陆状态；
> 2. 因为`iframe`的原因，如果能读取`DOM`,`BOM`，那么随便就可以做一个伪网站，获取用户信息；
> 3. 你打开的病毒网站就可以请求另一个你打开的银行网站的转账API，导致你的损失。

#### 二、现阶段跨域的解决方案及案例
---

##### 1. 服务端设置`Access-Control-Allow-Origin`

这种方法也是我们工作中最常用的发放，从字面意思可以翻译为*跨域允许的源*。这个参数是设置在请求的API返回信息的`headers`中，如果设置为*号，就表示告诉浏览器，这个API允许任意源的请求，浏览器就不会对返回信息进行拦截了，当然也可以单独指定单个的源。