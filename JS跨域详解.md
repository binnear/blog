因项目本地开发时，调用API都是涉及到跨域的问题，而现在前端工程化，前端构建工具会集成跨域的功能，因此也没有深入地区探究跨域的问题，而自己本身也对跨域问题还有一些模糊之处，因此决定写下这篇文章，督促自己了解的同时，也是做个记录，方便以后回顾。

#### 本文目录结构：
---

1. 什么是跨域
2. 现阶段跨域的解决方案及案例
3. 最佳实践

#### 一、什么是跨域
---

##### 1. 跨域的两个误区

> 1.动态请求就会有跨域问题
> 2.跨域就是请求发不出去

对于误区1，跨域仅仅存在与浏览器端，不存在于其他环境；对于误区2，只要网络没有问题，所有跨域的请求都是能正常发送出去，并且服务端也能收到请求并正常返回结果，只是由于跨域限制，被浏览器拦截了。（这也是为什么我们用postman等代理工具模拟请求时，可以获取到返回信息;如果是非简单请求，除`GET`,`POST`,`HEAD`之外的请求，都会出发预请求。）
  
参考：[跨來源資源共用（CORS）][cors]
[cors]: https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS


##### 2. 为什么跨域仅仅限制读取远端的数据

如果限制写入端（也就是发送请求端），那么服务器的资源仅仅只能同源请求，无法做到资源共享。

##### 3. 浏览器如何识别一个请求是否跨域

> 浏览器识别跨域是基于[同源策略][sameOrigin]
[sameOrigin]: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy

同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
  
如果两个页面的协议（如：`http`,`https`）、域名（如：`binnera.com.cn`）、端口（一般web网站都是默认80端口）都相同，则两个页面具有相同的源，而只要其中任意一个不同，则浏览器则会将这两个源之间的请求视为跨域。

##### 4. 浏览器跨域限制主要限制了什么

> 1. 不同的源无法读取对方的`Cookie`、`LocalStorage` 和 `IndexDB`；
> 2. 无法获取`DOM`,`BOM`；
> 3. JS无法获取`AJAX`以及Fetch请求的结果。

##### 5. 跨域三种限制所应对的实际问题

> 1. 如果能读取其他源的`cookie`，那么就可以获取你的登陆了信息，模拟你的登陆状态；
> 2. 因为`iframe`的原因，如果能读取`DOM`,`BOM`，那么随便就可以做一个伪网站，获取用户信息；
> 3. 你打开的病毒网站就可以请求另一个你打开的银行网站的转账API，导致你的损失。

##### 6. 浏览器允许的跨域资源请求

浏览器允许嵌入跨域资源的请求
> `<script src="..."></script>`标签嵌入跨域脚本;
> `<link rel="stylesheet" href="...">` 标签嵌入CSS,CSS的跨域需要一个设置正确的Content-Type 消息头;
> `<img>`嵌入图片；
> `<video>` 和 `<audio>`嵌入多媒体资源；
> `@font-face` 引入的字体；
> `<frame>` 和 `<iframe>` 载入的任何资源，可通过设置X-Frame-Options消息头来阻止iframe嵌入资源。


#### 二、现阶段跨域的解决方案及案例
---

##### 1. 服务端设置`Access-Control-Allow-Origin`

这种方法也是我们工作中最常用的发放，从字面意思可以翻译为*跨域允许的源*。这个参数是设置在请求的API返回信息的`headers`中，如果设置为*号，就表示告诉浏览器，这个API允许任意源的请求，浏览器就不会对返回信息进行拦截了，当然也可以单独指定某个源。

##### 2. JSONP跨域

相信每一个接触过跨域的程序员都或多或少了解过JSONP跨域，它的原理也很简单，就是利用上面我们提过的嵌入跨域资源请求的方法。

```js
<script type='text/javascript'>
    function localFn(data) {
        console.log('这是获取到的远程数据'：data)
    }
    const script = document.createElement('script');
    script.src = 'http://binnear.com.cn?callback=localFn';
    document.body.appendChild(script);
</script>
```

1. 首先我们定义了一个全局函数localFn;
2. 创建一个script标签，并将src属性指向我们需要跨域请求的API;
3. 将创建的script标签添加到页面

通过以上3步，我们发送上面所示的API请求，然后服务端会返回一段可执行的JS代码

```js
localFn({remark: '我是远程数据对象里面的属性值'})
```

因为我们之前定义了全局的`localFn`，所以这段代码就会执行`localFn`这个函数，并将数据传递给形参`data`，在`localFn`内我们就通过`data`获取到服务端的数据了。
  
注意点：`crc`中的`localFn`可以为任意名，`callback`这个`key`是由接口提供者所定义。

##### 3. 